// Package lint runs linters as part of go test.
//
// It is intended to be used as a substitute for an external build
// step that runs tools such as go vet or golint.
//
package lint

import (
	"reflect"

	"github.com/surullabs/lint/checkers"
	"github.com/surullabs/lint/errcheck"
	"github.com/surullabs/lint/gofmt"
	"github.com/surullabs/lint/golint"
	"github.com/surullabs/lint/gosimple"
	"github.com/surullabs/lint/gostaticcheck"
	"github.com/surullabs/lint/govet"
)

// Default holds a default list of lint tools for convenient use. These include
//
//     - gofmt -d
//     - go tool vet -shadow
//     - golint
//     - gosimple (https://github.com/dominikh/go-simple)
//     - gostaticcheck (https://github.com/dominikh/go-staticcheck)
//     - errcheck (https://github.com/kisielk/errcheck)
var Default = Group{
	gofmt.Check{},         // Verify that all files are properly formatted
	govet.Shadow,          // go vet
	golint.Check{},        // golint
	gosimple.Check{},      // honnef.co/go/simple
	gostaticcheck.Check{}, // honnef.co/go/staticcheck
	errcheck.Check{},
}

type errors interface {
	Errors() []string
}

// Checker is the interface that wraps the Check method.
//
// Check lints all files in pkgs. Each item in pkgs may be a fully
// qualified import path, relative import path or a path with the wildcard
// suffix ...
type Checker interface {
	Check(pkgs ...string) error
}

// Group is a Checker list that is applied in sequence. See Check for details on
// how it is applied.
type Group []Checker

// Check applies each of checkers in g in the order provided.
//
// The error returned is either nil or contains errors returned by each Checker.
// These are exposed using the errors interface described in Skip and prefixed with the type of the
// Checker that generated the error. For example, the following error generated by govet.Checker:
//
//    file.go:23: err is unintentionally shadowed.
//
// is converted to:
//
//    govet.Checker: file.go:23: err is unintentionally shadowed.
//
// A checker is not shorted-circuited by a previous checker returning an error.
//
// Any error that implements errors is flattened into the final error list.
func (g Group) Check(pkgs ...string) error {
	var errs []string
	for _, checker := range g {
		name := reflect.TypeOf(checker).String()
		switch err := checker.Check(pkgs...).(type) {
		case nil:
			continue
		case errors:
			cerrs := err.Errors()
			for _, e := range cerrs {
				errs = append(errs, name+": "+e)
			}
		default:
			errs = append(errs, name+": "+err.Error())
		}
	}
	if len(errs) == 0 {
		return nil
	}
	return checkers.Error(errs...)
}

// With returns a copy of g with checkers appended
func (g Group) With(checkers ...Checker) Group {
	copied := make([]Checker, len(g))
	copy(copied, g)
	return Group(append(copied, checkers...))
}
